{"version":3,"sources":["components/controlbar.jsx","components/node.jsx","algorithms/dijkstra.js","algorithms/animate.js","components/pathfinder.jsx","components/App.jsx","serviceWorker.js","index.js"],"names":["Controlbar","renderTitle","style","display","justifyContent","alignItems","flexDirection","marginRight","marginLeft","fontSize","marginBottom","marginTop","renderAlgorithms","props","algorithm","algorithms","onAlgorithmSelect","animateCompletion","algorithmsArray","push","Button","key","className","onClick","disabled","charAt","toUpperCase","slice","Fragment","color","href","id","role","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","padding","margin","border","renderAddons","onAddonSelect","selectedAddon","Group","active","renderControlButtons","onVisualize","onPause","onReset","animateState","animated","Content","visible","Icon","name","hidden","state","this","Component","Node","handleClass","isStart","isEnd","isBarrier","isCheckpoint","isWeight","checkpointNumber","weight","onMouseDown","onMouseUp","onMouseEnter","e","icon","faPlayCircle","faStopCircle","toString","faCircle","faWeightHanging","findClosestUnvisited","grid","dimensions","length","closestUnvisited","distanceToStart","Infinity","row","column","visited","findUnvisitedNeighbors","currentNode","neighbors","location","dijkstra","dijkstraGrid","map","node","prevNode","NaN","mapGrid","visitedNodes","shortestPath","unvisitedNeighbors","neighbor","newDistance","unshift","createNewGrid","newGrid","r","newRow","c","dijkstraCheckpoints","checkpoints","start","findStart","end","findEnd","short","splice","animateNodes","currentNodes","interval","Promise","resolve","reject","setTimeout","element","document","getElementById","classList","contains","remove","offsetWidth","add","assert","require","Pathfinder","algorithmIndex","shortestPathIndex","barriers","weights","selectedWeight","mouse","down","button","renderContainer","onMouseLeave","handleMouseUp","renderNodes","rowIndex","handleMouseDown","handleMouseEnter","runAlgorithm","animateAlgorithms","a","aIndex","aStateChecker","localCompletion","animateNodesBind","bind","sIndex","sStateChecker","console","log","setState","handleVisualize","toast","error","handlePausePlay","newState","handleReset","nodes","handleAlgorithmSelect","handleAddonSelect","addon","findNode","nodeId","toggleNode","preIndex","split","indexArray","parseInt","newCheckpoints","index","findIndex","checkpoint","cNumber","checkpointNode","generateGrid","currentRow","filter","App","Boolean","window","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.b509ab80.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport { Button, Icon } from \"semantic-ui-react\";\r\n\r\nclass Controlbar extends Component {\r\n  renderTitle = () => {\r\n    return (\r\n      <div\r\n        style={{\r\n          display: \"flex\",\r\n          justifyContent: \"center\",\r\n          alignItems: \"center\",\r\n          flexDirection: \"column\",\r\n          marginRight: \"50px\",\r\n          marginLeft: \"35px\",\r\n        }}\r\n      >\r\n        <p style={{ fontSize: \"30px\", marginBottom: \"5px\", marginTop: \"5px\" }}>\r\n          Pathfind\r\n        </p>\r\n        <p style={{ fontSize: \"15px\", marginBottom: \"5px\", marginTop: \"5px\" }}>\r\n          Visualization Tool\r\n        </p>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  renderAlgorithms = () => {\r\n    const {\r\n      algorithm,\r\n      algorithms,\r\n      onAlgorithmSelect,\r\n      animateCompletion,\r\n    } = this.props;\r\n    let algorithmsArray = [];\r\n    for (const algorithm of algorithms) {\r\n      algorithmsArray.push(\r\n        <Button\r\n          key={algorithm}\r\n          className=\"dropdown-item\"\r\n          onClick={() => onAlgorithmSelect(algorithm)}\r\n          //will remove as algorithms are added\\\r\n          disabled\r\n        >\r\n          {algorithm.charAt(0).toUpperCase() + algorithm.slice(1)}\r\n        </Button>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <React.Fragment>\r\n        <li className=\"nav-item\">\r\n          <p className=\"nav-link\" style={{ color: \"black\" }}>\r\n            Algorithm:\r\n          </p>\r\n        </li>\r\n        <li className=\"nav-item dropdown\">\r\n          <Button\r\n            className=\"nav-link dropdown-toggle\"\r\n            href=\"#\"\r\n            id=\"navbarDropdown\"\r\n            role=\"button\"\r\n            data-toggle=\"dropdown\"\r\n            aria-haspopup=\"true\"\r\n            aria-expanded=\"false\"\r\n            disabled={animateCompletion === 2 || animateCompletion === 3}\r\n          >\r\n            {algorithm.charAt(0).toUpperCase() + algorithm.slice(1)}\r\n          </Button>\r\n          <div\r\n            className=\"dropdown-menu\"\r\n            aria-labelledby=\"navbarDropdown\"\r\n            style={{\r\n              fontSize: \"15px\",\r\n              padding: \"0\",\r\n              margin: \"0\",\r\n              border: \"0px solid black\",\r\n            }}\r\n          >\r\n            {algorithmsArray}\r\n          </div>\r\n        </li>\r\n      </React.Fragment>\r\n    );\r\n  };\r\n\r\n  renderAddons = () => {\r\n    const { onAddonSelect, selectedAddon } = this.props;\r\n    return (\r\n      <React.Fragment>\r\n        <li className=\"nav-item\">\r\n          <p className=\"nav-link\" style={{ color: \"black\" }}>\r\n            Add-on Nodes:\r\n          </p>\r\n        </li>\r\n        <li className=\"nav-item\">\r\n          <Button.Group>\r\n            <Button\r\n              active={selectedAddon === \"barriers\"}\r\n              onClick={() => onAddonSelect(\"barriers\")}\r\n            >\r\n              Barrier\r\n            </Button>\r\n            <Button\r\n              active={selectedAddon === \"weights\"}\r\n              onClick={() => onAddonSelect(\"weights\")}\r\n            >\r\n              Weighted\r\n            </Button>\r\n            <Button\r\n              active={selectedAddon === \"checkpoints\"}\r\n              onClick={() => onAddonSelect(\"checkpoints\")}\r\n            >\r\n              Checkpoint\r\n            </Button>\r\n          </Button.Group>\r\n        </li>\r\n      </React.Fragment>\r\n    );\r\n  };\r\n\r\n  renderControlButtons = () => {\r\n    const {\r\n      onVisualize,\r\n      onPause,\r\n      onReset,\r\n      animateState,\r\n      animateCompletion,\r\n    } = this.props;\r\n    return (\r\n      <div className=\"m-auto align-items-center\">\r\n        <Button animated onClick={onReset} disabled={animateCompletion === 1}>\r\n          <Button.Content visible>\r\n            <Icon name=\"redo alternate\" />\r\n          </Button.Content>\r\n          <Button.Content hidden>Reset</Button.Content>\r\n        </Button>\r\n        <Button\r\n          color=\"purple\"\r\n          onClick={onVisualize}\r\n          disabled={animateCompletion !== 1}\r\n          animated\r\n        >\r\n          <Button.Content visible>Visualize!</Button.Content>\r\n          <Button.Content hidden>Visualize!</Button.Content>\r\n        </Button>\r\n        <Button\r\n          animated\r\n          onClick={onPause}\r\n          disabled={animateCompletion === 1 || animateCompletion === 4}\r\n        >\r\n          <Button.Content visible>\r\n            <Icon\r\n              name={\r\n                !animateState &&\r\n                animateCompletion !== 1 &&\r\n                animateCompletion !== 4\r\n                  ? \"play\"\r\n                  : \"pause\"\r\n              }\r\n            />\r\n          </Button.Content>\r\n          <Button.Content hidden>\r\n            {!animateState && animateCompletion !== 1 && animateCompletion !== 4\r\n              ? \"Play\"\r\n              : \"Pause\"}\r\n          </Button.Content>\r\n        </Button>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\r\n        {this.renderTitle()}\r\n        <ul className=\"navbar-nav\" style={{ fontSize: \"15px\" }}>\r\n          {this.renderAlgorithms()}\r\n        </ul>\r\n        {this.renderControlButtons()}\r\n        <ul className=\"navbar-nav\" style={{ fontSize: \"15px\" }}>\r\n          {this.renderAddons()}\r\n        </ul>\r\n      </nav>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Controlbar;\r\n","import React, { Component } from \"react\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport {\r\n  faWeightHanging,\r\n  faCircle,\r\n  faPlayCircle,\r\n  faStopCircle,\r\n} from \"@fortawesome/free-solid-svg-icons\";\r\nimport \"../css/node.css\";\r\n\r\nclass Node extends Component {\r\n  state = {};\r\n\r\n  handleClass = () => {\r\n    const { isStart, isEnd, isBarrier, isCheckpoint, isWeight } = this.props;\r\n    if (isStart) return \"node start\";\r\n    if (isEnd) return \"node end\";\r\n    if (isBarrier) return \"node barrier\";\r\n    if (isWeight) return \"node weight\";\r\n    if (isCheckpoint) return \"node checkpoint\";\r\n    return \"node default\";\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      id,\r\n      isStart,\r\n      isEnd,\r\n      isCheckpoint,\r\n      checkpointNumber,\r\n      isWeight,\r\n      weight,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n    } = this.props;\r\n    return (\r\n      <td\r\n        className={this.handleClass()}\r\n        id={id}\r\n        onMouseDown={(e) => onMouseDown(e, id)}\r\n        onMouseUp={(e) => onMouseUp()}\r\n        onMouseEnter={(e) => onMouseEnter(id)}\r\n        // onContextMenu={(e) => e.preventDefault()}\r\n      >\r\n        {isStart && <FontAwesomeIcon icon={faPlayCircle} />}\r\n        {isEnd && <FontAwesomeIcon icon={faStopCircle} />}\r\n        {isCheckpoint && (\r\n          <span className=\"fa-layers\">\r\n            <span className={\"fa-layers-text checkpoint-label\"}>\r\n              {checkpointNumber.toString()}\r\n            </span>\r\n            <FontAwesomeIcon icon={faCircle} />\r\n          </span>\r\n        )}\r\n        {isWeight && (\r\n          <span className=\"fa-layers\">\r\n            <span className={\"fa-layers-text weight-label\"}>\r\n              {weight.toString()}\r\n            </span>\r\n            <FontAwesomeIcon icon={faWeightHanging} />\r\n          </span>\r\n        )}\r\n      </td>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","function mapGrid(grid) {\r\n  return grid.map((row) => {\r\n    return row.map((node) => {\r\n      if (node.isBarrier) {\r\n        return {\r\n          ...node,\r\n          visited: true,\r\n          distanceToStart: node.isStart ? 0 : Infinity,\r\n          prevNode: {\r\n            row: NaN,\r\n            column: NaN,\r\n          },\r\n        };\r\n      }\r\n      return {\r\n        ...node,\r\n        visited: false,\r\n        distanceToStart: node.isStart ? 0 : Infinity,\r\n        prevNode: {\r\n          row: NaN,\r\n          column: NaN,\r\n        },\r\n      };\r\n    });\r\n  });\r\n}\r\n\r\nfunction findClosestUnvisited(grid) {\r\n  const dimensions = {\r\n    row: grid.length,\r\n    column: grid[0].length,\r\n  };\r\n\r\n  let closestUnvisited = { distanceToStart: Infinity };\r\n\r\n  for (let row = 0; row < dimensions.row; row++) {\r\n    for (let column = 0; column < dimensions.column; column++) {\r\n      if (!grid[row][column].visited) {\r\n        if (\r\n          grid[row][column].distanceToStart < closestUnvisited.distanceToStart\r\n        ) {\r\n          closestUnvisited = grid[row][column];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return closestUnvisited;\r\n}\r\n\r\nfunction findUnvisitedNeighbors(currentNode, grid) {\r\n  let neighbors = [];\r\n  if (grid[currentNode.location.row + 1]) {\r\n    if (\r\n      !grid[currentNode.location.row + 1][currentNode.location.column].visited\r\n    ) {\r\n      neighbors.push(\r\n        grid[currentNode.location.row + 1][currentNode.location.column]\r\n      );\r\n    }\r\n  }\r\n  if (grid[currentNode.location.row][currentNode.location.column + 1]) {\r\n    if (\r\n      !grid[currentNode.location.row][currentNode.location.column + 1].visited\r\n    ) {\r\n      neighbors.push(\r\n        grid[currentNode.location.row][currentNode.location.column + 1]\r\n      );\r\n    }\r\n  }\r\n  if (grid[currentNode.location.row - 1]) {\r\n    if (\r\n      !grid[currentNode.location.row - 1][currentNode.location.column].visited\r\n    ) {\r\n      neighbors.push(\r\n        grid[currentNode.location.row - 1][currentNode.location.column]\r\n      );\r\n    }\r\n  }\r\n  if (grid[currentNode.location.row][currentNode.location.column - 1]) {\r\n    if (\r\n      !grid[currentNode.location.row][currentNode.location.column - 1].visited\r\n    ) {\r\n      neighbors.push(\r\n        grid[currentNode.location.row][currentNode.location.column - 1]\r\n      );\r\n    }\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nexport function dijkstra(grid) {\r\n  let dijkstraGrid = mapGrid(grid);\r\n\r\n  let visitedNodes = [];\r\n  let currentNode = { isEnd: false };\r\n  while (!currentNode.isEnd) {\r\n    currentNode = findClosestUnvisited(dijkstraGrid);\r\n    if (currentNode.distanceToStart === Infinity) {\r\n      return { shortestPath: [], visitedNodes };\r\n    }\r\n    currentNode.visited = true;\r\n    // console.log(currentNode);\r\n\r\n    const unvisitedNeighbors = findUnvisitedNeighbors(\r\n      currentNode,\r\n      dijkstraGrid\r\n    );\r\n    // console.log(neighbors);\r\n\r\n    for (let neighbor of unvisitedNeighbors) {\r\n      const newDistance = currentNode.distanceToStart + neighbor.weight;\r\n      if (newDistance < neighbor.distanceToStart) {\r\n        neighbor.distanceToStart = newDistance;\r\n        neighbor.prevNode = currentNode;\r\n      }\r\n      dijkstraGrid[neighbor.location.row][neighbor.location.column] = neighbor;\r\n    }\r\n\r\n    dijkstraGrid[currentNode.location.row][\r\n      currentNode.location.column\r\n    ] = currentNode;\r\n    visitedNodes.push([{ id: currentNode.id }]);\r\n  }\r\n\r\n  // const startNode = findStart(dijkstraGrid);\r\n\r\n  // const endNode = currentNode;\r\n\r\n  let shortestPath = [];\r\n\r\n  while (!currentNode.isStart) {\r\n    shortestPath.unshift([{ id: currentNode.id }]);\r\n    currentNode = currentNode.prevNode;\r\n  }\r\n  shortestPath.unshift([{ id: currentNode.id }]);\r\n\r\n  // console.log(shortestPath);\r\n  // console.log(visitedNodes);\r\n\r\n  return { shortestPath, visitedNodes };\r\n}\r\n\r\nfunction findStart(grid) {\r\n  const dimensions = {\r\n    row: grid.length,\r\n    column: grid[0].length,\r\n  };\r\n\r\n  for (let r = 0; r < dimensions.row; r++) {\r\n    for (let c = 0; c < dimensions.column; c++) {\r\n      if (grid[r][c].isStart) {\r\n        return grid[r][c];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findEnd(grid) {\r\n  const dimensions = {\r\n    row: grid.length,\r\n    column: grid[0].length,\r\n  };\r\n\r\n  for (let r = 0; r < dimensions.row; r++) {\r\n    for (let c = 0; c < dimensions.column; c++) {\r\n      if (grid[r][c].isEnd) {\r\n        return grid[r][c];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createNewGrid(grid) {\r\n  let newGrid = [];\r\n  for (let r = 0; r < grid.length; r++) {\r\n    let newRow = [];\r\n    for (let c = 0; c < grid[0].length; c++) {\r\n      newRow.push({\r\n        id: r.toString() + \"-\" + c.toString(),\r\n        location: { row: r, column: c },\r\n        weight: grid[r][c].weight,\r\n        isStart: false,\r\n        isEnd: false,\r\n        isBarrier: grid[r][c].isBarrier,\r\n        isCheckpoint: false,\r\n        isWeight: grid[r][c].isWeight,\r\n      });\r\n    }\r\n    newGrid.push(newRow);\r\n  }\r\n  return newGrid;\r\n}\r\n\r\nexport function dijkstraCheckpoints(grid, checkpoints) {\r\n  const start = findStart(grid);\r\n  const end = findEnd(grid);\r\n\r\n  let shortestPath = [];\r\n  let visitedNodes = [];\r\n\r\n  for (let c = 0; c <= checkpoints.length; c++) {\r\n    const newGrid = createNewGrid(grid);\r\n    if (c === 0) {\r\n      newGrid[start.location.row][start.location.column].isStart = true;\r\n      newGrid[checkpoints[c].location.row][\r\n        checkpoints[c].location.column\r\n      ].isEnd = true;\r\n      let { shortestPath: short, visitedNodes: visited } = dijkstra(newGrid);\r\n      // console.log(short);\r\n      shortestPath.push(...short);\r\n      visitedNodes.push(...visited);\r\n    } else if (c === checkpoints.length) {\r\n      newGrid[checkpoints[c - 1].location.row][\r\n        checkpoints[c - 1].location.column\r\n      ].isStart = true;\r\n      newGrid[end.location.row][end.location.column].isEnd = true;\r\n      let { shortestPath: short, visitedNodes: visited } = dijkstra(newGrid);\r\n      short.splice(0, 1);\r\n      shortestPath.push(...short);\r\n      visitedNodes.push(...visited);\r\n    } else {\r\n      newGrid[checkpoints[c - 1].location.row][\r\n        checkpoints[c - 1].location.column\r\n      ].isStart = true;\r\n      newGrid[checkpoints[c].location.row][\r\n        checkpoints[c].location.column\r\n      ].isEnd = true;\r\n      let { shortestPath: short, visitedNodes: visited } = dijkstra(newGrid);\r\n      short.splice(0, 1);\r\n      shortestPath.push(...short);\r\n      visitedNodes.push(...visited);\r\n    }\r\n  }\r\n  return { shortestPath, visitedNodes };\r\n}\r\n","export function animateNodes(currentNodes, style, interval) {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      for (const node of currentNodes) {\r\n        let element = document.getElementById(node.id);\r\n        if (element.classList.contains(style)) {\r\n          element.classList.remove(style);\r\n          void element.offsetWidth;\r\n          //   element.classList.add(style);\r\n          // } else {\r\n          //   element.className = style;\r\n          // }\r\n        }\r\n        element.classList.add(style);\r\n      }\r\n      resolve(true);\r\n    }, interval);\r\n  });\r\n}\r\n\r\n// export function animateDijkstra(visitedNodes) {\r\n//   return new Promise((resolve, reject) => {\r\n//     for (let n = 0; n < visitedNodes.length; n++) {\r\n//       setTimeout(() => {\r\n//         const node = visitedNodes[n];\r\n//         document.getElementById(node.id).className = \"node visited\";\r\n//       }, 10 * n);\r\n//     }\r\n//     setTimeout(() => {\r\n//       resolve(true);\r\n//     }, 10 * visitedNodes.length);\r\n//   });\r\n// }\r\n\r\n// export function animateShortestPath(shortestPath) {\r\n//   return new Promise((resolve, reject) => {\r\n//     for (let n = shortestPath.length - 1; n >= 0; n--) {\r\n//       setTimeout(() => {\r\n//         const node = shortestPath[n];\r\n//         document.getElementById(node.id).className = \"node shortest-path\";\r\n//       }, 40 * (shortestPath.length - n - 1));\r\n//     }\r\n//     setTimeout(() => {\r\n//       resolve(true);\r\n//     }, 10 * shortestPath.length);\r\n//   });\r\n// }\r\n","import React, { Component } from \"react\";\r\nimport Controlbar from \"./controlbar\";\r\nimport Node from \"./node\";\r\nimport { dijkstra, dijkstraCheckpoints } from \"./../algorithms/dijkstra\";\r\nimport { animateNodes } from \"../algorithms/animate\";\r\nimport { toast } from \"react-toastify\";\r\nimport \"../css/pathfinder.css\";\r\n\r\nvar assert = require(\"assert\");\r\n\r\nclass Pathfinder extends Component {\r\n  state = {\r\n    grid: [],\r\n    start: {\r\n      row: 10,\r\n      column: 20,\r\n    },\r\n    end: {\r\n      row: 10,\r\n      column: 40,\r\n    },\r\n    algorithm: \"dijkstra\",\r\n    algorithms: [\"dijkstra\", \"algorithm 1\", \"algorithm 2\", \"algorithm 3\"],\r\n    animateState: false,\r\n    animateCompletion: 1, //1 for not started, 2 for algorithm animated started, 3 for shortestpath started, 4 for completed\r\n    visitedNodes: [],\r\n    shortestPath: [],\r\n    algorithmIndex: 0,\r\n    shortestPathIndex: 0,\r\n    barriers: [],\r\n    checkpoints: [],\r\n    weights: [],\r\n    selectedAddon: \"barriers\",\r\n    selectedWeight: 5,\r\n    mouse: { down: false, button: NaN },\r\n  };\r\n\r\n  dimensions = {\r\n    //if these values are to be modified, change node.css dimensions to match\r\n    row: 21,\r\n    column: 60,\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = this.generateGrid(this.dimensions);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  isStart = (row, column) => {\r\n    const { start } = this.state;\r\n\r\n    if (start.row === row && start.column === column) return true;\r\n    return false;\r\n  };\r\n\r\n  isEnd = (row, column) => {\r\n    const { end } = this.state;\r\n\r\n    if (end.row === row && end.column === column) return true;\r\n    return false;\r\n  };\r\n\r\n  generateGrid({ row, column }) {\r\n    let grid = [];\r\n\r\n    for (let r = 0; r < row; r++) {\r\n      let currentRow = [];\r\n\r\n      for (let c = 0; c < column; c++) {\r\n        currentRow.push({\r\n          id: r.toString() + \"-\" + c.toString(),\r\n          location: { row: r, column: c },\r\n          weight: 1,\r\n          isStart: this.isStart(r, c),\r\n          isEnd: this.isEnd(r, c),\r\n          isBarrier: false,\r\n          isCheckpoint: false,\r\n          checkpointNumber: NaN,\r\n          isWeight: false,\r\n        });\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n\r\n    return grid;\r\n  }\r\n\r\n  renderContainer = (grid) => {\r\n    return (\r\n      <table className=\"node-grid\" onMouseLeave={() => this.handleMouseUp()}>\r\n        <tbody>{this.renderNodes(grid)}</tbody>\r\n      </table>\r\n    );\r\n  };\r\n\r\n  renderNodes = (grid) => {\r\n    return grid.map((row, rowIndex) => {\r\n      return (\r\n        <tr className=\"node-row\" key={rowIndex} id={rowIndex}>\r\n          {row.map((node) => {\r\n            return (\r\n              <Node\r\n                key={node.id}\r\n                id={node.id}\r\n                location={node.location}\r\n                weight={node.weight}\r\n                isStart={node.isStart}\r\n                isEnd={node.isEnd}\r\n                isBarrier={node.isBarrier}\r\n                isCheckpoint={node.isCheckpoint}\r\n                checkpointNumber={node.checkpointNumber}\r\n                isWeight={node.isWeight}\r\n                onMouseDown={this.handleMouseDown}\r\n                onMouseUp={this.handleMouseUp}\r\n                onMouseEnter={this.handleMouseEnter}\r\n              />\r\n            );\r\n          })}\r\n        </tr>\r\n      );\r\n    });\r\n  };\r\n\r\n  runAlgorithm = (algorithm, grid, checkpoints) => {\r\n    if (algorithm === \"dijkstra\") {\r\n      if (checkpoints.length === 0) {\r\n        return dijkstra(grid);\r\n      } else {\r\n        return dijkstraCheckpoints(grid, checkpoints);\r\n      }\r\n      // console.log(dijkstraCheckpoints(grid, checkpoints));\r\n      // return dijkstraCheckpoints(grid, checkpoints);\r\n      // return dijkstra(grid);\r\n    }\r\n  };\r\n\r\n  animateAlgorithms = async (\r\n    animateCompletion,\r\n    visitedNodes,\r\n    shortestPath,\r\n    algorithmIndex,\r\n    shortestPathIndex\r\n  ) => {\r\n    //needed in this file since function does state checking through every iteration\r\n\r\n    let localCompletion = animateCompletion;\r\n\r\n    let aIndex = algorithmIndex;\r\n    let aStateChecker = localCompletion === 2 ? true : false;\r\n    while (aStateChecker) {\r\n      // await animateNodes(visitedNodes[aIndex], \"node visited\", 10);\r\n      let animateNodesBind = animateNodes.bind(this);\r\n      await animateNodesBind(visitedNodes[aIndex], \"visited\", 10);\r\n      aIndex++;\r\n      aStateChecker = this.state.animateState;\r\n      if (aIndex === visitedNodes.length) {\r\n        aStateChecker = false;\r\n        localCompletion = 3;\r\n      }\r\n    }\r\n\r\n    let sIndex = 0;\r\n    if (shortestPath.length > 0) {\r\n      sIndex = shortestPathIndex;\r\n      let sStateChecker = localCompletion === 3 ? true : false;\r\n      while (sStateChecker) {\r\n        // await animateNodes(shortestPath[sIndex], \"node shortest-path\", 40);\r\n        let animateNodesBind = animateNodes.bind(this);\r\n        await animateNodesBind(shortestPath[sIndex], \"shortest-path\", 40);\r\n        sIndex++;\r\n        sStateChecker = this.state.animateState;\r\n        if (sIndex === shortestPath.length) {\r\n          localCompletion = 4;\r\n          console.log(\"Completed\");\r\n          sStateChecker = false;\r\n        }\r\n      }\r\n    }\r\n    this.setState({\r\n      algorithmIndex: aIndex,\r\n      shortestPathIndex: sIndex,\r\n      animateCompletion: localCompletion,\r\n      animateState: false,\r\n    });\r\n  };\r\n\r\n  handleVisualize = async () => {\r\n    const {\r\n      animateState,\r\n      animateCompletion,\r\n      grid,\r\n      algorithm,\r\n      shortestPathIndex,\r\n      algorithmIndex,\r\n      checkpoints,\r\n    } = this.state;\r\n    assert(animateState === false && animateCompletion === 1);\r\n    this.setState({ animateState: true, animateCompletion: 2 });\r\n\r\n    const { shortestPath, visitedNodes } = this.runAlgorithm(\r\n      algorithm,\r\n      grid,\r\n      checkpoints\r\n    );\r\n    // console.log(visitedNodes);\r\n    // console.log(shortestPath);\r\n\r\n    if (shortestPath.length === 0) {\r\n      toast.error(\"No path to destination was found...\");\r\n    }\r\n\r\n    this.setState({ shortestPath, visitedNodes });\r\n\r\n    console.log(\"Initiating\");\r\n\r\n    await this.animateAlgorithms(\r\n      2,\r\n      visitedNodes,\r\n      shortestPath,\r\n      algorithmIndex,\r\n      shortestPathIndex\r\n    );\r\n  };\r\n\r\n  handlePausePlay = async () => {\r\n    const {\r\n      animateState,\r\n      animateCompletion,\r\n      shortestPath,\r\n      visitedNodes,\r\n      shortestPathIndex,\r\n      algorithmIndex,\r\n    } = this.state;\r\n    assert(animateCompletion === 2 || animateCompletion === 3);\r\n\r\n    let newState = !animateState;\r\n    this.setState({ animateState: newState });\r\n\r\n    if (newState === true) {\r\n      console.log(\"Resuming\");\r\n      await this.animateAlgorithms(\r\n        animateCompletion,\r\n        visitedNodes,\r\n        shortestPath,\r\n        algorithmIndex,\r\n        shortestPathIndex\r\n      );\r\n    } else {\r\n      console.log(\"Paused\");\r\n    }\r\n  };\r\n\r\n  handleReset = () => {\r\n    const { animateCompletion, grid } = this.state;\r\n\r\n    // assert(animateCompletion !== 1);\r\n    this.setState({ animateState: false }); //stops animation\r\n    setTimeout(() => {\r\n      //resets everything\r\n      for (let nodes of grid) {\r\n        for (let node of nodes) {\r\n          if (node.isStart) {\r\n            document.getElementById(node.id).className = \"node start\";\r\n          } else if (node.isEnd) {\r\n            document.getElementById(node.id).className = \"node end\";\r\n          } else if (node.isBarrier) {\r\n            document.getElementById(node.id).className = \"node barrier\";\r\n          } else if (node.isCheckpoint) {\r\n            document.getElementById(node.id).className = \"node checkpoint\";\r\n          } else if (node.isWeight) {\r\n            document.getElementById(node.id).className = \"node weight\";\r\n          } else {\r\n            document.getElementById(node.id).className = \"node default\";\r\n          }\r\n        }\r\n      }\r\n      this.setState({\r\n        animateCompletion: 1,\r\n        algorithmIndex: 0,\r\n        shortestPathIndex: 0,\r\n        visitedNodes: [],\r\n        shortestPath: [],\r\n      });\r\n      console.log(\"Terminated\");\r\n    }, 11);\r\n  };\r\n\r\n  handleAlgorithmSelect = (algorithm) => {\r\n    this.setState({ algorithm });\r\n    this.handleReset();\r\n  };\r\n\r\n  handleAddonSelect = (addon) => {\r\n    this.setState({ selectedAddon: addon });\r\n  };\r\n\r\n  findNode = (nodeId, grid) => {\r\n    const dimensions = {\r\n      row: grid.length,\r\n      column: grid[0].length,\r\n    };\r\n\r\n    for (let r = 0; r < dimensions.row; r++) {\r\n      for (let c = 0; c < dimensions.column; c++) {\r\n        if (grid[r][c].id === nodeId) {\r\n          return grid[r][c];\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  toggleNode = (button, nodeId) => {\r\n    const {\r\n      grid,\r\n      selectedAddon,\r\n      selectedWeight,\r\n      checkpoints,\r\n      animateCompletion,\r\n    } = this.state;\r\n    let newGrid = grid;\r\n\r\n    if (animateCompletion !== 1) {\r\n      return toast.error(\r\n        \"Please reset or clear the board before making changes!\"\r\n      );\r\n    }\r\n\r\n    const preIndex = nodeId.split(\"-\");\r\n    let indexArray = [];\r\n    for (const element of preIndex) {\r\n      indexArray.push(parseInt(element));\r\n    }\r\n    let node = newGrid[indexArray[0]][indexArray[1]];\r\n\r\n    let newCheckpoints = checkpoints;\r\n    if (button === 0) {\r\n      if (\r\n        !node.isStart &&\r\n        !node.isEnd &&\r\n        !node.isWeight &&\r\n        !node.isCheckpoint &&\r\n        !node.isBarrier\r\n      ) {\r\n        if (selectedAddon === \"barriers\") {\r\n          node.isBarrier = true;\r\n        } else if (selectedAddon === \"weights\") {\r\n          node.isWeight = true;\r\n          node.weight = selectedWeight;\r\n        } else if (selectedAddon === \"checkpoints\") {\r\n          newCheckpoints.push(node);\r\n          node.checkpointNumber = newCheckpoints.length;\r\n          node.isCheckpoint = true;\r\n        }\r\n      }\r\n    } else if (button === 2) {\r\n      node.isBarrier = false;\r\n      node.isCheckpoint = false;\r\n      const index = checkpoints.findIndex(\r\n        (checkpoint) => checkpoint.id === node.id\r\n      );\r\n      if (index !== -1) {\r\n        newCheckpoints.splice(index, 1);\r\n        let cNumber = 1;\r\n        for (let checkpoint of newCheckpoints) {\r\n          const checkpointNode = this.findNode(checkpoint.id, newGrid);\r\n          newGrid[checkpointNode.location.row][\r\n            checkpointNode.location.column\r\n          ].checkpointNumber = cNumber;\r\n          cNumber++;\r\n        }\r\n      }\r\n      node.checkpointNumber = NaN;\r\n      node.isWeight = false;\r\n      node.weight = 1;\r\n    }\r\n\r\n    newGrid[indexArray[0]][indexArray[1]] = node;\r\n    this.setState({ grid: newGrid, checkpoints: newCheckpoints });\r\n  };\r\n\r\n  handleMouseDown = (e, nodeId) => {\r\n    this.toggleNode(e.button, nodeId);\r\n    this.setState({ mouse: { down: true, button: e.button } });\r\n  };\r\n\r\n  handleMouseEnter = (nodeId) => {\r\n    const { mouse } = this.state;\r\n\r\n    if (mouse.down) {\r\n      this.toggleNode(mouse.button, nodeId);\r\n    }\r\n  };\r\n\r\n  handleMouseUp = () => {\r\n    this.setState({ mouse: { down: false, button: NaN } });\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      grid,\r\n      animateState,\r\n      animateCompletion,\r\n      algorithm,\r\n      algorithms,\r\n      selectedAddon,\r\n    } = this.state;\r\n    return (\r\n      <React.Fragment>\r\n        <Controlbar\r\n          onVisualize={this.handleVisualize}\r\n          onPause={this.handlePausePlay}\r\n          onReset={this.handleReset}\r\n          animateState={animateState}\r\n          animateCompletion={animateCompletion}\r\n          algorithm={algorithm}\r\n          algorithms={algorithms.filter((a) => a !== algorithm)}\r\n          onAlgorithmSelect={this.handleAlgorithmSelect}\r\n          onAddonSelect={this.handleAddonSelect}\r\n          selectedAddon={selectedAddon}\r\n        />\r\n        <div>{this.renderContainer(grid)}</div>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Pathfinder;\r\n","import React, { Component } from \"react\";\nimport Pathfinder from \"./pathfinder\";\nimport { ToastContainer } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\nimport \"../css/App.css\";\n\nclass App extends Component {\n  state = {};\n\n  render() {\n    return (\n      <React.Fragment>\n        <ToastContainer />\n        <Pathfinder />\n      </React.Fragment>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./css/index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"bootstrap/dist/js/bootstrap.js\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}